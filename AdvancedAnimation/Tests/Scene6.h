#ifndef SCENE6_H
#define SCENE6_H

#include <iostream>
#include <time.h>
#include <vector>

using namespace std;

class Scene6 : public Test {
public:
	Scene6(){
		m_world->SetGravity(b2Vec2(0, -10));

		TestMain::GetFilesNames(geomFile_, neuronFile_);

		vector<vector<b2Vec2>> geomRead;
		vector<vector<b2Vec2>> particiones;
		vector<b2Vec2> neurons;
		vector<int> loops;
		vector<float>  times;

		// { Read Geom and Partition File}
		for (unsigned int numfile = 0; numfile < geomFile_.size(); ++numfile){
			FILE *archivo;
			archivo = fopen(geomFile_.at(numfile).c_str(), "r");

			float x, y;
			int maxParticles;
			unsigned int r, g, b, a;
			unsigned int vertices, partitions, emiters, loop;
			
			fscanf(archivo, "%u", &vertices);
			fscanf(archivo, "%u", &partitions);
			fscanf(archivo, "%u", &emiters);
			fscanf(archivo, "%d", &loop);
			loops.push_back(loop);

			// Geom
			geomRead.push_back(vector<b2Vec2>());
			for (unsigned int cont = 0; cont < vertices; ++cont)
			{
				fscanf(archivo, "%f %f", &x, &y);
				maxX = max(x, maxX);
				minX = min(x, minX);
				maxY = max(y, maxY);
				minY = min(y, minY);
				geomRead.at(numfile).push_back(b2Vec2(x, y));
			}
			Zoom = max((maxX - minX), (maxY - minY)) / 2;
			// Partition
			particiones.push_back(vector<b2Vec2>());
			for (unsigned int cont = 0; cont < partitions; ++cont){
				fscanf(archivo, "%f %f", &x, &y);
				particiones.at(numfile).push_back(b2Vec2(x, y));
			}

			if (emiters > 0){
				fscanf(archivo, "%f %d", &x, &maxParticles);

				m_particleSystem->SetRadius(x);
				m_particleSystem->SetMaxParticleCount(maxParticles);
				m_particleSystem->SetDestructionByAge(true);

				const float32 faucetLength = m_particleSystem->GetRadius() * 2.0f * k_faucetLength;

				for (unsigned int cont = 0; cont < emiters; ++cont){
					RadialEmitter rEmit;

					rEmit.SetParticleSystem(m_particleSystem);
					fscanf(archivo, "%f %f", &x, &y);
					rEmit.SetPosition(b2Vec2(x, y));
					fscanf(archivo, "%f %f", &x, &y);
					rEmit.SetVelocity(b2Vec2(x, y));
					rEmit.SetSize(b2Vec2(0.0f, faucetLength));
					fscanf(archivo, "%u %u %u %u", &r, &g, &b, &a);
					rEmit.SetColor(b2ParticleColor((uint8)r, (uint8)g, (uint8)b, (uint8)a));
					fscanf(archivo, "%f", &x);
					rEmit.SetEmitRate(x);
					rEmit.SetParticleFlags(TestMain::GetParticleParameterValue());

					m_emitters.push_back(rEmit);
				}
			}
			fclose(archivo);

			
			for (unsigned int shape = 0; shape < geomRead.size(); ++shape){
				try {
					if (geomRead.at(shape).size() < 2) throw (int)geomRead.at(shape).size();
					// Vertex Geom
					b2BodyDef bd;
					b2Body* ground = m_world->CreateBody(&bd);
					b2ChainShape bodyGeom;

					if (loops.at(shape)){
						bodyGeom.CreateLoop(&(geomRead.at(shape))[0], geomRead.at(shape).size());		
					}
					else{
						bodyGeom.CreateChain(&(geomRead.at(shape))[0], geomRead.at(shape).size());
					}

					b2FixtureDef defB;
					defB.shape = &bodyGeom;
					ground->CreateFixture(&defB);

					if (particiones.at(shape).size() < 2) throw (int)particiones.at(shape).size();
					// Partition Vertex
					b2BodyDef bdP;
					b2Body* groundP = m_world->CreateBody(&bdP);
					b2ChainShape partitionGeom;

					partitionGeom.CreateChain(&particiones.at(shape)[0], particiones.at(shape).size());

					b2FixtureDef defP;
					defP.shape = &partitionGeom;
					groundP->CreateFixture(&defP);
				}
				catch (int error) {
					cerr << "shape: " << shape <<" "<< error<<" puntos. Debe contener al menos 2 puntos" << endl;
				}
			}			
		}
		// { Read Neuron File}
		if (neuronFile_ != ""){
			FILE *archivoNeuron;
			archivoNeuron = fopen(neuronFile_.c_str(), "r");

			string begin = "";
			char line[200];

			while (begin != "// Generated by GenerateConnectionsMFGR\n")
			{
				fgets(line, 100, archivoNeuron);
				begin = line;
			}

			unsigned int numConnections = 0;
			//fscanf(archivoNeuron, "%s %d %s", &aux1, &numConnections, &aux2);
			fscanf(archivoNeuron, "%s %d %s", line, &numConnections, line);

			int x1, x2, x3, x4, x5, x6, neuron1, neuron2;
			float y1, y2;

			for (unsigned int cont = 0; cont < numConnections; ++cont){
				fscanf(archivoNeuron, "%d %d %d %d %d %f %d %d %f %d",
					&neuron1, &x1, &neuron2, &x2, &x3, &y1, &x4, &x5, &y2, &x6);

				neurons.push_back(b2Vec2((float)neuron1, (float)neuron2));
			}

			fclose(archivoNeuron);
		}
		// Don't restart the test when changing particle types.
		TestMain::SetRestartOnParticleParameterChange(false);
		// Limit the set of particle types.
		TestMain::SetParticleParameters(k_paramDef, k_paramDefCount);
		// Create the particles.
		//ResetParticles();			
		time(&initHour);
	}

	void setFiles(const vector<string> geomFile, const string neuronFile){ geomFile_ = geomFile; neuronFile_ = neuronFile; }

	b2ParticleColor colorPorcentaje(int p){
		int intervalo = (p>0) + (p>20) + (p>40) + (p>60) + (p>80);
		switch (intervalo){
		case 0: return b2ParticleColor(0, 0, 0, 0); // Transparente
		case 1:	return b2ParticleColor(0, 255, 0, 255); // green
		case 2: return b2ParticleColor(255, 0, 255, 255);
		case 3: return b2ParticleColor(0, 0, 255, 255); // blue
		case 4: return b2ParticleColor(255, 255, 0, 255);
		case 5: return b2ParticleColor(255, 0, 0, 255); //red
		default:
			return b2ParticleColor(255, 255, 255, 255);
			break;
		}
	}

	virtual void Step(Settings* settings){
		Test::Step(settings);

		const float32 dt = 1.0f / settings->hz;
		m_particleColorOffset += dt;
		// Keep m_particleColorOffset in the range 0.0f..k_ParticleColorsCount.
		if (m_particleColorOffset >= (float32)k_ParticleColorsCount){ m_particleColorOffset -= (float32)k_ParticleColorsCount; }
		// Propagate the currently selected particle flags.
		for (unsigned int i = 0; i < m_emitters.size(); ++i){
			m_emitters.at(i).SetParticleFlags(TestMain::GetParticleParameterValue());
			//m_emitters.at(i).SetColor(colorPorcentaje(3));
			m_emitters.at(i).Step(dt, NULL, 0); // Create the particles.
		}
		
		time_t currentTime;
		time(&currentTime);

		double seg = difftime(currentTime, initHour);

		if (seg > 10){
			//m_emitters.at(2).SetPosition(b2Vec2(1000.0f, -600.0f));

		}
		m_debugDraw.DrawString(700, 60, "Time { %02u : %02u }", (unsigned int)seg / 60, (unsigned int)seg % 60);
	}

	// Determine whether a point is in the container.
	bool InContainer(const b2Vec2& p) const{ return p.x >= -k_containerHalfWidth && p.x <= k_containerHalfWidth && p.y >= 0.0f && p.y <= k_containerHalfHeight * 2.0f; }
	float32 GetDefaultViewZoom() const{ return (Zoom <= 1) ? pow(Zoom, 2) : sqrt(Zoom); }
	void GetCam(float &w, float &h) const{ w = (maxX + minX) / 2; h = (maxY + minY) / 2; }
	static Test* Create(){ return new Scene6; }

private:
	float32 m_particleColorOffset;
	vector<RadialEmitter> m_emitters;
	int32 porcentaje;
	int32 porcentaje2;
	int32 porcentaje3;
	int32 porcentaje4;

	float32 m_position;
	//float32 m_position2;
	//float32 m_position3;

	b2Body* m_barrierBody;
	//b2Body* m_barrierBody2;
	//b2Body* m_barrierBody3;
	b2ParticleGroup* m_particleGroup;

	float maxX = -FLT_MAX, minX = FLT_MAX, maxY = -FLT_MAX, minY = FLT_MAX;

	time_t initHour;

private:
	static const int32 k_maxParticleCount;
	static const ParticleParameter::Value k_paramValues[];
	static const ParticleParameter::Definition k_paramDef[];
	static const uint32 k_paramDefCount;

	static const float32 k_containerWidth;
	static const float32 k_containerHeight;
	static const float32 k_containerHalfWidth;
	static const float32 k_containerHalfHeight;
	static const float32 k_barrierHeight;
	static const float32 k_barrierMovementIncrement;

	static const float32 k_faucetLength;
	static const float32 k_faucetWidth;
	static const float32 k_faucetHeight;
};

const float32 Scene6::k_faucetLength = 2.0f;
const float32 Scene6::k_faucetWidth = 0.1f;
const float32 Scene6::k_faucetHeight = 15.0f;
				   
const float32 Scene6::k_containerWidth = 2.0f;
const float32 Scene6::k_containerHeight = 5.0f;
				   
const float32 Scene6::k_containerHalfWidth = Scene6::k_containerWidth / 2.0f;
const float32 Scene6::k_containerHalfHeight = Scene6::k_containerHeight / 2.0f;
const float32 Scene6::k_barrierHeight = Scene6::k_containerHalfHeight / 100.0f;
const float32 Scene6::k_barrierMovementIncrement = Scene6::k_containerHalfHeight * 0.1f;


const int32 Scene6::k_maxParticleCount = 10000;
const ParticleParameter::Value Scene6::k_paramValues[] = {
	{ b2_waterParticle, ParticleParameter::k_DefaultOptions, "water" },
	{ b2_waterParticle, ParticleParameter::k_DefaultOptions | ParticleParameter::OptionStrictContacts, "water (strict)" },
	{ b2_viscousParticle, ParticleParameter::k_DefaultOptions, "viscous" },
	{ b2_powderParticle, ParticleParameter::k_DefaultOptions, "powder" },
	{ b2_tensileParticle, ParticleParameter::k_DefaultOptions, "tensile" },
	{ b2_colorMixingParticle, ParticleParameter::k_DefaultOptions, "color mixing" },
	{ b2_staticPressureParticle, ParticleParameter::k_DefaultOptions, "static pressure" }, };

const ParticleParameter::Definition Scene6::k_paramDef[] = { { Scene6::k_paramValues, B2_ARRAY_SIZE(Scene6::k_paramValues) }, };
const uint32 Scene6::k_paramDefCount = B2_ARRAY_SIZE(Scene6::k_paramDef);

#endif